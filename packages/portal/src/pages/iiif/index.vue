<template>
  <div>
    <div id="viewer" />
  </div>
</template>

<script>
  import uniq from 'lodash/uniq';

  export default {
    name: 'IIIFPage',

    layout: 'minimal',

    asyncData({ query }) {
      return {
        uri: query.uri,
        searchQuery: query.query
      };
    },

    data() {
      return {
        manifest: null,
        MIRADOR_BUILD_PATH: 'https://cdn.jsdelivr.net/npm/mirador@3.3.0/dist',
        page: null,
        imageToCanvasMap: {},
        mirador: null,
        showAnnotations: false,
        miradorStoreManifestJsonUnsubscriber: () => {}
      };
    },

    head() {
      return {
        meta: [
          { hid: 'title', name: 'title', content: 'IIIF' }
        ],
        script: [
          { src: `${this.MIRADOR_BUILD_PATH}/mirador.min.js` }
        ]
      };
    },

    computed: {
      miradorViewerOptions() {
        // Doc: https://github.com/ProjectMirador/mirador/blob/v3.3.0/src/config/settings.js
        const options = {
          id: 'viewer',
          windows: [
            {
              manifestId: this.uri,
              thumbnailNavigationPosition: 'far-right'
            }
          ],
          window: {
            allowClose: false,
            allowFullscreen: true,
            allowMaximize: false,
            allowTopMenuButton: true,
            allowWindowSideBar: false,
            sideBarOpen: false,
            panels: {
              info: false,
              attribution: false,
              canvas: false,
              annotations: true,
              search: true
            },
            defaultSideBarPanel: this.searchQuery ? 'search' : 'annotations',
            views: [
              { key: 'single' },
              { key: 'book' },
              { key: 'gallery' }
            ]
          },
          workspace: {
            showZoomControls: true,
            type: 'mosaic'
          },
          workspaceControlPanel: {
            enabled: false
          },
          requests: {
            postprocessors: [this.postprocessMiradorRequest]
          },
          // thumbnailNavigation: {
          //   width: 145 // width of one canvas (doubled for book view) in ThumbnailNavigation area when position is "far-right"
          // },
          selectedTheme: 'europeana',
          themes: {
            europeana: {
              palette: {
                type: 'light',
                primary: {
                  main: '#0a72cc'
                },
                secondary: {
                  main: '#0a72cc'
                },
                shades: {
                  dark: '#000000',
                  main: 'rgba(255 255 255 / 90%)',
                  light: '#ffffff'
                },
                error: {
                  main: '#e02020'
                },
                notification: { // Color used in MUI Badge dots
                  main: '#0a72cc'
                },
                action: {
                  hover: '#ffffff',
                  hoverOpacity: 0
                }
              },
              typography: {
                fontFamily: ['Open Sans', 'Arial', 'sans-serif'],
                body1: {
                  fontSize: '1rem',
                  letterSpacing: '0',
                  lineHeight: '1.5'
                },
                body2: {
                  fontSize: '1rem',
                  letterSpacing: '0',
                  lineHeight: '1.5'
                }
              }
            }
          }
        };

        return options;
      },

      iiifPresentationApiVersion() {
        if (this.manifest['@context'] === 'http://iiif.io/api/presentation/2/context.json') {
          return 2;
        } else if (this.manifest['@context'] === 'http://iiif.io/api/presentation/3/context.json') {
          return 3;
        } else {
          return undefined;
        }
      }
    },

    mounted() {
      this.$nextTick(() => {
        this.mirador = window.Mirador.viewer(this.miradorViewerOptions);
        this.miradorStoreManifestJsonUnsubscriber = this.mirador.store.subscribe(this.miradorStoreManifestJsonListener);
      });
    },

    methods: {
      miradorStoreManifestJsonListener() {
        const miradorWindow = Object.values(this.mirador.store.getState().windows)[0]; // only takes one window into account at the moment
        if (miradorWindow) {
          const miradorManifest = this.mirador.store.getState().manifests[miradorWindow.manifestId];
          if (miradorManifest) {
            this.manifest = miradorManifest.json;
            if (miradorWindow.canvasId && (miradorWindow.canvasId !== this.page)) {
              this.memoiseImageToCanvasMap();
              this.page = miradorWindow.canvasId;
              this.postUpdatedDownloadLinkMessage(this.page);
            }
          }
        }
      },

      postprocessMiradorRequest(url, action) {
        switch (action.type) {
        case 'mirador/RECEIVE_MANIFEST':
          this.postprocessMiradorManifest(url, action);
          break;
        case 'mirador/RECEIVE_ANNOTATION':
          if ((action.annotationJson.resources.length > 0)) {
            const windowId = Object.keys(this.mirador.store.getState().windows)[0];
            if (!this.showAnnotations) {
              if (this.searchQuery) {
                const companionWindowId = Object.keys(this.mirador.store.getState().companionWindows)[0];
                const searchId = `${this.manifest.service['@id']}?q=${this.searchQuery}`;

                const actionSearch = window.Mirador.actions.fetchSearch(windowId, companionWindowId, searchId, this.searchQuery);
                this.mirador.store.dispatch(actionSearch);
              }
              const action = window.Mirador.actions.toggleWindowSideBar(windowId);
              this.mirador.store.dispatch(action);
              this.showAnnotations = true;

              this.miradorViewerOptions.window.allowWindowSideBar = true;
              const actionShow = window.Mirador.actions.updateConfig(this.miradorViewerOptions);
              this.mirador.store.dispatch(actionShow);
            }
          }
          this.postprocessMiradorAnnotation(url, action);
          break;
        case 'mirador/RECEIVE_SEARCH':
          this.postprocessMiradorSearch(url, action);
          break;
        }
      },

      postprocessMiradorManifest(url, action) {
        this.addTextGranularityFilterToManifest(action.manifestJson);
      },

      postprocessMiradorAnnotation(url, action) {
        this.coerceResourcesOnToCanvases(action.annotationJson);
        this.dereferenceAnnotationResources(action.annotationJson);
      },

      postprocessMiradorSearch(url, action) {
        this.filterSearchHitsByTextGranularity(action.searchJson);
        this.coerceResourcesOnToCanvases(action.searchJson);
        this.coerceSearchHitsToBeforeMatchAfter(action.searchJson);
      },

      addTextGranularityFilterToManifest(manifestJson, textGranularity = 'Line') {
        const europeanaIiifPattern = /^https?:\/\/iiif\.europeana\.eu\/presentation\/[^/]+\/[^/]+\/manifest$/;
        if (!europeanaIiifPattern.test(manifestJson['@id'])) {
          return;
        }

        // Add textGranularity filter to "otherContent" URIs
        for (const sequence of manifestJson.sequences) {
          for (const canvas of (sequence.canvases || [])) {
            const otherContent = canvas.otherContent || [];
            for (let i = 0; i < otherContent.length; i = i + 1) {
              const otherContentLink = otherContent[i];
              const paramSeparator = otherContentLink.includes('?') ? '&' : '?';
              otherContent[i] = `${otherContentLink}${paramSeparator}textGranularity=${textGranularity}`;
            }
          }
        }

        // Add textGranularity filter to search service URI
        //
        // NOTE: this does not work, due to Mirador not expecting a service URI
        //       to already contain '?' with parameters.
        //       https://github.com/ProjectMirador/mirador/blob/v3.0.0/src/components/SearchPanelControls.js#L91
        //
        //       If it in future becomes possible to use this, then `filterSearchHitsByTextGranularity`
        //       becomes redundant and may be removed, as pre-filtering on the
        //       service side is preferrable.
        //
        // if ((manifestJson.service || {}).profile === 'http://iiif.io/api/search/1/search') {
        //   const paramSeparator = manifestJson.service['@id'].includes('?') ? '&' : '?';
        //   manifestJson.service['@id'] = `${manifestJson.service['@id']}${paramSeparator}textGranularity=${textGranularity}`;
        // }
      },

      filterSearchHitsByTextGranularity(searchJson, textGranularity = 'Line') {
        searchJson.resources = searchJson.resources.filter(resource => !resource.dcType || (resource.dcType === textGranularity));
        const filteredResourceIds = searchJson.resources.map(resource => resource['@id']);
        searchJson.hits = searchJson.hits.filter(hit => hit.annotations.some(anno => filteredResourceIds.includes(anno)));
      },

      coerceResourcesOnToCanvases(json) {
        json.resources = json.resources.map(this.coerceResourceOnImagesToCanvases);
      },

      memoiseImageToCanvasMap() {
        if (this.iiifPresentationApiVersion === 2) {
          this.imageToCanvasMap = this.manifest.sequences.reduce((memo, sequence) => {
            for (const canvas of sequence.canvases) {
              for (const image of canvas.images) {
                memo[image.resource['@id']] = canvas['@id'];
              }
            }
            return memo;
          }, {});
        }
        // TODO: do we also need memoisation for v3?
      },

      canvasForImage(imageId) {
        const splitImageId = imageId.split('#');
        if (this.imageToCanvasMap[splitImageId[0]]) {
          return [this.imageToCanvasMap[splitImageId[0]], splitImageId[1]].join('#');
        } else {
          return null;
        }
      },

      // HACK to force `on` attribute to canvas ID, from invalid targetting of image ID
      //
      // TODO: remove when API output updated to use canvas ID.
      //       Affects annotation lists for:
      //       - full pages of annotations linked to from otherContent in Presentation manifests
      //       - lists of annotations with search hits
      coerceResourceOnImagesToCanvases(resource) {
        if (Array.isArray(resource.on)) {
          for (let i = 0; i < resource.on.length; i = i + 1) {
            const canvas = this.canvasForImage(resource.on[i]);
            if (canvas) {
              resource.on[i] = canvas;
            }
          }
        } else {
          const canvas = this.canvasForImage(resource.on);
          if (canvas) {
            resource.on = canvas;
          }
        }

        return resource;
      },

      // HACK to flatten oa:TextQuoteSelector hit selectors to before/match/after
      // hits, as Mirador 3.0.0 does not support oa:TextQuoteSelector style.
      coerceSearchHitsToBeforeMatchAfter(searchJson) {
        const hits = [];

        for (const hit of (searchJson.hits || [])) {
          if (hit.selectors) {
            for (const selector of hit.selectors) {
              hits.push({
                '@type': hit['@type'],
                annotations: hit.annotations,
                before: selector.prefix,
                after: selector.suffix,
                match: selector.exact
              });
            }
          } else {
            hits.push(hit);
          }
        }

        searchJson.hits = hits;
      },

      fetchAnnotationResourcesFulltext(annotationJson) {
        const urls = annotationJson.resources
          .filter(resource => !resource.resource.chars && resource.resource['@id'])
          .map(resource => resource.resource['@id'].split('#')[0]);

        const fulltext = {};

        // TODO: error handling
        const fetches = uniq(urls).map(url => this.$axios.get(url)
          .then(response => response.data)
          .then((data) => {
            if (data.type === 'FullTextResource') {
              fulltext[url] = data.value;
            }
          }));

        return Promise.all(fetches).then(() => fulltext);
      },

      async dereferenceAnnotationResources(annotationJson) {
        const fulltext = await this.fetchAnnotationResourcesFulltext(annotationJson);

        for (const resource of annotationJson.resources) {
          if (resource.resource.chars || !resource.resource['@id']) {
            continue;
          }

          const url = resource.resource['@id'].split('#')[0];
          if (!fulltext[url]) {
            continue;
          }

          const fragment = resource.resource['@id'].split('#')[1];

          resource.resource.chars = fulltext[url];

          if (fragment) {
            const charMatch = fragment.match(/char=(\d+),(\d+)$/);
            if (charMatch) {
              resource.resource.chars = resource.resource.chars.slice(
                Number(charMatch[1]),
                Number(charMatch[2]) + 1
              );
            }
          }
        }
      },

      postUpdatedDownloadLinkMessage(pageId) {
        if (!this.manifest) {
          return;
        }

        let link;

        if (this.iiifPresentationApiVersion === 2) {
          link = this.manifest.sequences[0].canvases
            .find(canvas => canvas['@id'] === pageId)
            ?.images?.[0]?.resource?.['@id'];
        } else if (this.iiifPresentationApiVersion === 3) {
          link = this.manifest.items
            .find(canvas => canvas.id === pageId)
            ?.items?.[0]?.items?.[0]?.body?.id;
        }

        if (link) {
          window.parent.postMessage({ event: 'updateDownloadLink', id: link }, window.location.origin);
        }
      }
    }
  };
</script>

<style lang="scss" scoped>
  @import '@/assets/scss/variables';
  @import '@/assets/scss/iiif';
</style>
